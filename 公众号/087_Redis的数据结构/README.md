## 前言

**Redis** 是一个高性能的分布式内存数据库，在国内的公司也有着非常广泛的使用场景。因此，在面试过程中，关于 **Redis** 相关的知识点，也是经常被问到的。

下面这题，就是之前面试的时候遇到过的，让我们一起来学习一下吧~

> **Redis** 有那些数据结构？以及它们的使用场景？

## Redis五种数据结构

**Redis** 为我们提供了 **5** 种数据结构，分别是以下几种：

- **String**（终究是我扛下来所有）
- **Hash**（存储对象我也行）
- **List**（栈和队列我都行）
- **Set**（标签系统我在行）
- **Sort Set**（排起名来我最棒）

然而，在我们的实际编程开发中，有大多数的开发者仅仅只会使用简单的 **Redis** 的 **String** 类型，也就是里面的 **Get** 和 **Set** 方法

> 当然也包括我，终究还是用 String 扛下了全部

```java
// 设置键值
stringRedisTemplate.opsForValue().set("key", "value");
// 获取键值
stringRedisTemplate.opsForValue().get("key");
```

下面，就让我们一起来深入学习 **Redis** 的 **5** 种数据类型，以便能够在不同的业务场景中游刃有余，而不是做一个只会用 **String** 的同学。

## 字符串

字符串类型是 **Redis** 最基础的数据结构，其他几种数据结构都是在字符串类型基础上构建的。

字符串类型的值是字符串（简单的字符串、复杂的字符串（例如 **JSON**、**XML**））、数字（整数、浮点数），甚至是二进制（图片、音频、视频）等。

![image-20200626095844113](images/0ea04e5760f7441d9478c319f34871fe.png)

字符串对象的内部编码有 **3** 种 ：**int**、**raw** 和 **embstr**，**Redis** 会根据当前值的类型和长度来决定使用哪种编码来实现

- **int**：如果一个字符串对象保存的是整数值,并且这个整数值可以用`long`类型来表示
- **raw**：如果字符串对象保存的是一个字符串值,并且这个字符串值的长度大于32字节
- **embstr**：如果字符串对象保存的是一个字符串值,并且这个字符申值的长度小于等于32字节

**Reids** 字符串的使用场景是最为广泛的，甚至有些对 **Redis** 其它几种对象不太熟悉的人，基本所有场景都会使用字符串(序列化一下直接扔进去),这让本身很单纯的字符串承受了它这个年纪本不该承受的重量。其实 **Redis** 的主要使用场景主要有以下几种:

- 作为缓存层,缓存热点数据
- **Redis** 字符串可以自增自减的特性可以用来做计数器、限速器、自增ID生成等
- 分布式系统的 **Session** 共享
- 二进制数据的存储

## 哈希

哈希对象用来存储一组数据对，每个数据对又包含键值两部分

![image-20200626101327742](images/46f7a913f51645e9a7ff3342548dc677.png)

Hash对象也有两种实现方式：**ziplist**（压缩列表）和 **hashtable**（哈希表）

同样，只有当存储的数据量比较小的情况下，Redis才使用压缩列表来实现哈希对象，具体需要满足两个条件

- 字典中保存的键和值的大小都要小于 **64** 字节
- 字典中键值对的个数要小于 **512** 个

当不能同时满足上面的两个条件时，**Redis** 就使用哈希表来实现Hash对象

当存储的内容是对象的时候，**Redis** 字符串对象很多功能使用Redis 哈希对象也可以实现，如缓存用户信息的时候，使用 **Redis** 哈希对象存储，简单直观，如果使用合理可以减少内存空间的使用。

但是也有其缺点，就是要控制哈希在 **ziplist** 和 **hashtable** 两种内部编码的转换，**hashtable**   将会消耗更多的内存。

此外，Hash对象还可以实现购物车和计数器等功能

## 列表

列表这种对象支持存储一组有序的，且可以重复的数据。因为其有序性，它可以获取指定范围的元素列表，可以在 **O(1)** 的时间复杂度获取指定索引的下标的元素等。

![image-20200626105857594](images/ed98879546e048f89d1121f8bd596728.png)

在 **Redis3.2** 版本以前列表类型的内部编码有两种。当满足下面两个条件的时候，**Redis** 列表对象使用 **ziplist**（压缩列表）来实现。

- 当列表的元素个数小于 **list-max-ziplist-entries** 配置（默认512个）
- 当列表中每个元素的值都小于 **list-max-ziplist-value** 配置时（默认64字节）

当列表类型无法满足 **ziplist** 条件时，Redis会使用linkedList作为列表的内部实现。

而在Redis3.2版本开始怼列表数据结构进行改造，使用quickList代替了zipList和linkedList。

由于列表对象的有序且不可重复的特性，它比较适合用来做文章、商品等列表的存储。

列表类型可以lpush（左侧push），同时又可以使用rpop（右侧弹出）第一个元素，所以列表类型具有先进先出的特性，可以用来实现消息队列，也可以lpush（左侧push）和lpop（左侧弹出），具有后进先出的特性，因此开发中需要使用栈的时候，我们可以使用列表对象来实现。

## 集合

集合对象是一个无序且唯一的键值集合。它的存储顺序不会按照插入的先后顺序进行存储，与列表不同的是它存储的数据是无序且不重复的。

![image-20200626122033221](images/a783d4694fed43f1bc177ceffc917bc0.png)

集合对象的内部编码也有两种，intest（整数集合）与hashtable（哈希表），当满足下面两个条件的时候，集合对象使用intset来实现

- 集合中的元素都是整数
- 集合中元素的个数小于 **set-maxintset-entries** 配置（默认 **512** 个）

不满足上面两个条件时，集合对象使用hashtable来实现

集合对象的主要两个特性就是：**无序**，**不可重复**，**支持并交差**，因此可以用来做标签系统

而集合中的 **SPOP** (随机移除并返回集合中一个或多个元素）和 **SRANDMEMBER** (随机返回集合中一个或多个元素) 命令可以帮助我们实现一个抽奖系统

## 有序集合

有序集合类型 ( **Sorted Set** 或 **ZSet** ) 相比于集合类型多了一个排序属性 **score**（分值），对于有序集合 **ZSet** 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。有序集合保留了集合不能有重复成员的特性(分值可以重复)，但不同的是，有序集合中的元素可以排序。

![image-20200626123309037](images/d21abdaa7fb94324a600abe3b602e450.png)

有序集合是由 **ziplist** (压缩列表)或 **skiplist** (跳跃表)组成的。

当数据比较少时，有序集合使用的是 **ziplist** 存储的，有序集合使用 **ziplist** 格式存储必须满足以下两个条件：

- 有序集合保存的元素个数要小于 **128** 个；
- 有序集合保存的所有元素成员的长度都必须小于 64 字节。

如果不能满足以上两个条件中的任意一个，有序集合将会使用 **skiplist** 结构进行存储。

有序集合比较典型的使用场景就是排行榜系统例如学生成绩的排名。某视频(博客等)网站的用户点赞、播放排名、电商系统中商品的销量排名等。

### 小结

**Redis** 提供了五种最基础也是最常用的对象(数据类型)：**String**、Hash、**List**、**Set**、ZSet。了解这五种对象的有助于我们更好的在日常开发中对Redis进行使用。